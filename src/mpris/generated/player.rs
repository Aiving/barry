//! # D-Bus interface proxy for: `org.mpris.MediaPlayer2.Player`
//!
//! This code was generated by `zbus-xmlgen` `4.1.0` from D-Bus introspection data.
//! Source: `interface.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use std::{collections::HashMap, str::FromStr};

use serde::{Deserialize, Serialize};
use zbus::{
    proxy,
    zvariant::{Error, OwnedObjectPath, OwnedValue, Type, Value},
};

#[derive(Debug, Type, Serialize, Deserialize)]
pub struct Metadata {
    #[serde(rename = "mpris:trackid")]
    pub track_id: Option<String>,
    #[serde(rename = "xesam:albumArtist")]
    pub album_artists: Option<Vec<String>>,
    #[serde(rename = "xesam:album")]
    pub album: Option<String>,
    #[serde(rename = "xesam:artist")]
    pub artists: Option<Vec<String>>,
    #[serde(rename = "xesam:title")]
    pub title: Option<String>,
    #[serde(rename = "xesam:autoRating")]
    pub auto_rating: Option<f64>,
    #[serde(rename = "xesam:discNumber")]
    pub disc_number: Option<i32>,
    #[serde(rename = "mpris:length")]
    pub length: Option<i64>,
    #[serde(rename = "xesam:trackNumber")]
    pub track_number: Option<i32>,
    #[serde(rename = "xesam:url")]
    pub url: Option<String>,
    #[serde(rename = "mpris:artUrl")]
    pub art_url: Option<String>,
}

impl Metadata {
    #[must_use]
    pub const fn is_empty(&self) -> bool {
        self.track_id.is_none()
            && self.album_artists.is_none()
            && self.album.is_none()
            && self.artists.is_none()
            && self.title.is_none()
            && self.auto_rating.is_none()
            && self.disc_number.is_none()
            && self.length.is_none()
            && self.track_number.is_none()
            && self.url.is_none()
            && self.art_url.is_none()
    }
}

trait MapExt {
    fn try_remove<T: for<'a> TryFrom<Value<'a>>>(&mut self, key: &str) -> Result<Option<T>, Error>;
}

impl MapExt for HashMap<String, Value<'_>> {
    fn try_remove<T: for<'a> TryFrom<Value<'a>>>(&mut self, key: &str) -> Result<Option<T>, Error> {
        if let Some(field) = self.remove(key) {
            Ok(Some(field.try_into().map_err(|_| Error::IncorrectType)?))
        } else {
            Ok(None)
        }
    }
}

impl TryFrom<OwnedValue> for Metadata {
    type Error = Error;

    fn try_from(value: OwnedValue) -> Result<Self, Self::Error> {
        let mut fields = <HashMap<String, Value>>::try_from(value)?;
        let track_id: Option<OwnedObjectPath> = fields.try_remove("mpris:trackid")?;

        Ok(Self {
            track_id: track_id.map(|track_id| track_id.to_string()),
            album_artists: fields.try_remove("xesam:albumArtist")?,
            album: fields.try_remove("xesam:album")?,
            artists: fields.try_remove("xesam:artist")?,
            title: fields.try_remove("xesam:title")?,
            auto_rating: fields.try_remove("xesam:autoRating")?,
            disc_number: fields.try_remove("xesam:discNumber")?,
            length: fields.try_remove("mpris:length")?,
            track_number: fields.try_remove("xesam:trackNumber")?,
            url: fields.try_remove("xesam:url")?,
            art_url: fields.try_remove("mpris:artUrl")?,
        })
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum PlaybackStatus {
    Playing,
    Paused,
    Stopped,
}

#[derive(Debug)]
pub struct InvalidPlaybackStatus(pub String);

impl FromStr for PlaybackStatus {
    type Err = InvalidPlaybackStatus;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Playing" => Ok(Self::Playing),
            "Paused" => Ok(Self::Paused),
            "Stopped" => Ok(Self::Stopped),
            value => Err(InvalidPlaybackStatus(value.to_string())),
        }
    }
}

impl TryFrom<OwnedValue> for PlaybackStatus {
    type Error = Error;

    fn try_from(value: OwnedValue) -> Result<Self, Self::Error> {
        let value = String::try_from(value)?;

        value.parse().map_err(|_| Error::IncorrectType)
    }
}

#[proxy(interface = "org.mpris.MediaPlayer2.Player", assume_defaults = true)]
trait Player {
    /// Next method
    fn next(&self) -> zbus::Result<()>;

    /// OpenUri method
    fn open_uri(&self, arg_1: &str) -> zbus::Result<()>;

    /// Pause method
    fn pause(&self) -> zbus::Result<()>;

    /// Play method
    fn play(&self) -> zbus::Result<()>;

    /// PlayPause method
    fn play_pause(&self) -> zbus::Result<()>;

    /// Previous method
    fn previous(&self) -> zbus::Result<()>;

    /// Seek method
    fn seek(&self, offset: i64) -> zbus::Result<()>;

    /// SetPosition method
    fn set_position(
        &self,
        track_id: &zbus::zvariant::ObjectPath<'_>,
        position: i64,
    ) -> zbus::Result<()>;

    /// Stop method
    fn stop(&self) -> zbus::Result<()>;

    /// Seeked signal
    #[zbus(signal)]
    fn seeked(&self, position: i64) -> zbus::Result<()>;

    /// CanControl property
    #[zbus(property)]
    fn can_control(&self) -> zbus::Result<bool>;

    /// CanGoNext property
    #[zbus(property)]
    fn can_go_next(&self) -> zbus::Result<bool>;

    /// CanGoPrevious property
    #[zbus(property)]
    fn can_go_previous(&self) -> zbus::Result<bool>;

    /// CanPause property
    #[zbus(property)]
    fn can_pause(&self) -> zbus::Result<bool>;

    /// CanPlay property
    #[zbus(property)]
    fn can_play(&self) -> zbus::Result<bool>;

    /// CanSeek property
    #[zbus(property)]
    fn can_seek(&self) -> zbus::Result<bool>;

    /// LoopStatus property
    #[zbus(property)]
    fn loop_status(&self) -> zbus::Result<String>;

    #[zbus(property)]
    fn set_loop_status(&self, value: &str) -> zbus::Result<()>;

    /// MaximumRate property
    #[zbus(property)]
    fn maximum_rate(&self) -> zbus::Result<f64>;

    /// Metadata property
    #[zbus(property)]
    fn metadata(&self) -> zbus::Result<Metadata>;

    /// MinimumRate property
    #[zbus(property)]
    fn minimum_rate(&self) -> zbus::Result<f64>;

    /// PlaybackStatus property
    #[zbus(property)]
    fn playback_status(&self) -> zbus::Result<PlaybackStatus>;

    /// Position property
    #[zbus(property)]
    fn position(&self) -> zbus::Result<i64>;

    /// Rate property
    #[zbus(property)]
    fn rate(&self) -> zbus::Result<f64>;

    #[zbus(property)]
    fn set_rate(&self, value: f64) -> zbus::Result<()>;

    /// Shuffle property
    #[zbus(property)]
    fn shuffle(&self) -> zbus::Result<bool>;

    #[zbus(property)]
    fn set_shuffle(&self, value: bool) -> zbus::Result<()>;

    /// Volume property
    #[zbus(property)]
    fn volume(&self) -> zbus::Result<f64>;

    #[zbus(property)]
    fn set_volume(&self, value: f64) -> zbus::Result<()>;
}
